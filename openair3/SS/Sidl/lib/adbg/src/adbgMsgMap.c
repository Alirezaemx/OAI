/*
 *****************************************************************
 *
 * Module : ACP Debug
 *
 * Purpose : THIS FILE IS AUTOMATICALLY GENERATED !
 *
 *****************************************************************
 *
 *  Copyright (c) 2019-2021 SEQUANS Communications.
 *  All rights reserved.
 *
 *  This is confidential and proprietary source code of SEQUANS
 *  Communications. The use of the present source code and all
 *  its derived forms is exclusively governed by the restricted
 *  terms and conditions set forth in the SEQUANS
 *  Communications' EARLY ADOPTER AGREEMENT and/or LICENCE
 *  AGREEMENT. The present source code and all its derived
 *  forms can ONLY and EXCLUSIVELY be used with SEQUANS
 *  Communications' products. The distribution/sale of the
 *  present source code and all its derived forms is EXCLUSIVELY
 *  RESERVED to regular LICENCE holder and otherwise STRICTLY
 *  PROHIBITED.
 *
 *****************************************************************
 */

// Internal includes
#include "adbgMsgMap.h"

/* #include "serTest.h" */
/* #include "serSys.h" */
/* #include "serSysSrb.h" */
#include "serNrSysSrb.h"
/* #include "serVng.h" */

/* #include "adbgTest.h" */
/* #include "adbgSys.h" */
/* #include "adbgSysSrb.h" */
#include "adbgNrSysSrb.h"
/* #include "adbgVng.h" */

void adbgMsgLogInArgs(acpCtx_t ctx, enum acpMsgLocalId id, size_t size, const unsigned char* buffer)
{
	if (id == ACP_LID_TestHelloFromSS) {
		return;
	}
#if 0
	if (id == 0x90040102 /* TestPing */) {
		return;
	}
	if (id == 0x90040103 /* TestEcho */) {
		return;
	}
	if (id == 0x90040104 /* TestTest1 */) {
		return;
	}
	if (id == 0x90040106 /* TestTest2 */) {
		return;
	}
	if (id == 0x90040106 /* TestOther */) {
		return;
	}
	if (id == 0x90050200 /* SysProcess */) {
		struct SYSTEM_CTRL_REQ* FromSS;
		if (serSysProcessDecSrv(buffer, size, NULL, 0, &FromSS) == 0) {
			adbgSysProcessLogIn(ctx, FromSS);
			serSysProcessFreeSrv(FromSS);
		} else {
			adbgPrintLog(ctx, "cannot decode buffer");
			adbgPrintLog(ctx, NULL);
		}
		return;
	}
	if (id == 0x90050300 /* SysSrbProcessFromSS */) {
		struct EUTRA_RRC_PDU_REQ* FromSS;
		if (serSysSrbProcessFromSSDecSrv(buffer, size, NULL, 0, &FromSS) == 0) {
			adbgSysSrbProcessFromSSLogIn(ctx, FromSS);

			serSysSrbProcessFromSSFreeSrv(FromSS);
		} else {
			adbgPrintLog(ctx, "cannot decode buffer");
			adbgPrintLog(ctx, NULL);
		}
		return;
	}
	if (id == 0x90050400 /* VngProcess */) {
		struct EUTRA_VNG_CTRL_REQ* FromSS;
		if (serVngProcessDecSrv(buffer, size, NULL, 0, &FromSS) == 0) {
			adbgVngProcessLogIn(ctx, FromSS);
			serVngProcessFreeSrv(FromSS);
		} else {
			adbgPrintLog(ctx, "cannot decode buffer");
			adbgPrintLog(ctx, NULL);
		}
		return;
	}
#endif
	if (id == ACP_LID_NrSysSrbProcessFromSS) {
		struct NR_RRC_PDU_REQ* FromSS;
		if (serNrSysSrbProcessFromSSDecSrv(buffer, size, NULL, 0, &FromSS) == 0) {
			adbgNrSysSrbProcessFromSSLogIn(ctx, FromSS);

			serNrSysSrbProcessFromSSFreeSrv(FromSS);
		} else {
			adbgPrintLog(ctx, "cannot decode buffer");
			adbgPrintLog(ctx, NULL);
		}
		return;
	}

	SIDL_ASSERT(0);
}

void adbgMsgLogOutArgs(acpCtx_t ctx, enum acpMsgLocalId id, size_t size, const unsigned char* buffer)
{
	if (id == ACP_LID_TestHelloToSS) {
		return;
	}
#if 0
	if (id == 0x90040102 /* TestPing */) {
		return;
	}
	if (id == 0x90040103 /* TestEcho */) {
		return;
	}
	if (id == 0x90040104 /* TestTest1 */) {
		return;
	}
	if (id == 0x90040106 /* TestTest2 */) {
		return;
	}
	if (id == 0x90040106 /* TestOther */) {
		return;
	}
	if (id == 0x90050200) {
		struct SYSTEM_CTRL_CNF* ToSS;
		if (serSysProcessDecClt(buffer, size, NULL, 0, &ToSS) == 0) {
			adbgSysProcessLogOut(ctx, ToSS);
			serSysProcessFreeClt(ToSS);
		} else {
			adbgPrintLog(ctx, "cannot decode buffer");
			adbgPrintLog(ctx, NULL);
		}
		return;
	}

	if (id == 0x90050301 /* SysSrbProcessToSS */) {
		struct EUTRA_RRC_PDU_IND* ToSS;
		if (serSysSrbProcessToSSDecClt(buffer, size, NULL, 0, &ToSS) == 0) {
			adbgSysSrbProcessToSSLogOut(ctx, ToSS);
			serSysSrbProcessToSSFreeClt(ToSS);
		} else {
			adbgPrintLog(ctx, "cannot decode buffer");
			adbgPrintLog(ctx, NULL);
		}
		return;
	}

	if (id == 0x90050400 /* VngProcess */) {
		struct EUTRA_VNG_CTRL_CNF* ToSS;
		if (serVngProcessDecClt(buffer, size, NULL, 0, &ToSS) == 0) {
			adbgVngProcessLogOut(ctx, ToSS);
			serVngProcessFreeClt(ToSS);
		} else {
			adbgPrintLog(ctx, "cannot decode buffer");
			adbgPrintLog(ctx, NULL);
		}
		return;
	}
#endif
	if (id == ACP_LID_NrSysSrbProcessToSS) {
		struct NR_RRC_PDU_IND* ToSS;
		if (serNrSysSrbProcessToSSDecClt(buffer, size, NULL, 0, &ToSS) == 0) {
			adbgNrSysSrbProcessToSSLogOut(ctx, ToSS);
			serNrSysSrbProcessToSSFreeClt(ToSS);
		} else {
			adbgPrintLog(ctx, "cannot decode buffer");
			adbgPrintLog(ctx, NULL);
		}
		return;
	}

	SIDL_ASSERT(0);
}
